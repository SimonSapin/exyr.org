    <p><a href="https://doc.rust-lang.org/book/second-edition/ch04-01-what-is-ownership.html">Ownership</a>
and <a href="https://doc.rust-lang.org/book/second-edition/ch04-02-references-and-borrowing.html">borrowing</a>
are the fundamentals of data structures in Rust.</p>
<p>However, both taking owneship of a value (moving it) or taking a reference to it
can only happen <em>after</em> the value was created.
This ordering seems to prevent having any cycle in a data structure,
even though that’s sometimes useful or necessary.
For example in a web page’s content tree, from any DOM node,
one can easily access (if any) its first and last child, previous and next sibling,
(so children of a node form a doubly-linked list) and parent.
Some other applications might need to manipulate arbitrary graphs in their full generality.</p>
<p>There a <a href="https://github.com/SimonSapin/rust-forest">few different approaches</a>
to work around this apparent limitation:</p>
<ul>
<li>Reference-counting with <code>Rc</code> or <code>Arc</code>,</li>
<li>Integer indices / identifiers into shared storage,</li>
<li><code>&amp;T</code> borrows / references with an arena allocator.</li>
</ul>
<p>This post focuses on the latter, since references are most ergonomic in my opinion.</p>
<p>Let’s build it step-by-step.
We’ll use <code>u32</code> integers as placeholders for a node’s payload,
arbitrary useful data associated to it.</p>
<h3>Building <code>&amp;T</code> reference cycles</h3>
<p>Before the compiler will even consider values that (indirectly) reference themselves,
we’ll need types that reference themselves.
A first naïve attempt produces a type that would take infinite space to spell out,
and the compiler doesn’t like that.</p>
<div class="codehilite"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">42_</span><span class="k">u32</span><span class="p">,</span><span class="w"> </span><span class="nb">None</span><span class="p">);</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">7_</span><span class="k">u32</span><span class="p">,</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">));</span><span class="w"></span>
<span class="c1">// error[E0308]: mismatched types</span>
<span class="n">a</span><span class="p">.</span><span class="mi">1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">b</span><span class="p">);</span><span class="w"></span>
<span class="c1">//    ^^^^^^^ cyclic type of infinite size</span>
</pre></div>


<p>We’ll need to make a type with a name so that its definition can be recursive.</p>
<div class="codehilite"><pre><span></span><span class="k">struct</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">value</span>: <span class="kt">u32</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">next</span>: <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="n">Node</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Node</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">value</span>: <span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="n">next</span>: <span class="nb">None</span> <span class="p">};</span><span class="w"></span>
<span class="c1">// error[E0506]: cannot assign to `a.next` because it is borrowed</span>
<span class="kd">let</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Node</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">value</span>: <span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="n">next</span>: <span class="nb">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="c1">//                                   - borrow of `a.next` occurs here</span>
<span class="n">a</span><span class="p">.</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">);</span><span class="w"></span>
<span class="c1">// ^^^^^^^^^^^^^^ assignment to borrowed `a.next` occurs here</span>
</pre></div>


<p>… aaand, today’s first borrow-checking error!</p>
<p>Assigning with <code>=</code> is similar to taking a <code>&amp;mut T</code> reference:
it requires exclusive access.
(By the way <code>&amp;mut T</code> and <code>&amp;T</code> should be called exclusive and shared references,
rather than mutable and immutable, since that’s what they’re really about.)</p>
<p>To be able to mutate part of a node while it is already borrow,
well use <code>Cell</code>’s
<a href="https://doc.rust-lang.org/book/second-edition/ch15-05-interior-mutability.html">interior mutability</a>.</p>
<div class="codehilite"><pre><span></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">cell</span>::<span class="n">Cell</span><span class="p">;</span><span class="w"></span>

<span class="k">struct</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">value</span>: <span class="kt">u32</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">next</span>: <span class="nc">Cell</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="n">Node</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Node</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">value</span>: <span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="n">next</span>: <span class="nc">Cell</span>::<span class="n">new</span><span class="p">(</span><span class="nb">None</span><span class="p">)</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Node</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">value</span>: <span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="n">next</span>: <span class="nc">Cell</span>::<span class="n">new</span><span class="p">(</span><span class="nb">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">))</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="c1">// error[E0597]: `b` does not live long enough</span>
<span class="n">a</span><span class="p">.</span><span class="n">next</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="nb">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">));</span><span class="w"></span>
<span class="c1">//               ^ borrowed value does not live long enough</span>
<span class="c1">// `b` dropped here while still borrowed</span>
</pre></div>


<p>Now we get to the heart of the issue: neither <code>a</code> or <code>b</code> is allowed to <em>outlive</em> the other.
The only way a cycle can be legal is if they have <em>the same lifetime</em>.</p>
<p>The way we had to write <code>&amp;'a Node&lt;'a&gt;</code>, repeating the same <code>'a</code> lifetime,
was already hinting at this.
The lifetime of the outer reference is the same as the one inside the referenced node.
If we tried to make them different like <code>&amp;'a Node&lt;'b&gt;</code>,
the <code>Node</code> struct would need two lifetime parameters.
But then the <code>next</code> field needs to be updated to
either <code>&amp;'a Node&lt;'b, 'b&gt;</code> which still constraints lifetimes in a cycle to be the same,
or <code>&amp;'a Node&lt;'b, 'c&gt;</code> which makes <code>Node</code> seem to need <em>three</em> lifetime parameters
and we’re back to types of infinite size.</p>
<p>One way to achieve same-lifetime is if the nodes are members of the same composite value,
such as a tuple:</p>
<div class="codehilite"><pre><span></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">cell</span>::<span class="n">Cell</span><span class="p">;</span><span class="w"></span>
<span class="k">struct</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">value</span>: <span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">next</span>: <span class="nc">Cell</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="n">Node</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">Node</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">value</span>: <span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">next</span>: <span class="nc">Cell</span>::<span class="n">new</span><span class="p">(</span><span class="nb">None</span><span class="p">)</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">    </span><span class="n">Node</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">value</span>: <span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="n">next</span>: <span class="nc">Cell</span>::<span class="n">new</span><span class="p">(</span><span class="nb">None</span><span class="p">)</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">    </span><span class="n">Node</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">value</span>: <span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="n">next</span>: <span class="nc">Cell</span>::<span class="n">new</span><span class="p">(</span><span class="nb">None</span><span class="p">)</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>

<span class="c1">// Create a cycle between b and c:</span>
<span class="n">a</span><span class="p">.</span><span class="n">next</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="nb">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">));</span><span class="w"></span>
<span class="n">b</span><span class="p">.</span><span class="n">next</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="nb">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="p">));</span><span class="w"></span>
<span class="n">c</span><span class="p">.</span><span class="n">next</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="nb">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">));</span><span class="w"></span>

<span class="c1">// Traverse the graph just to show it works:</span>
<span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">;</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">values</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Vec</span>::<span class="n">new</span><span class="p">();</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="p">..</span><span class="mi">10</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">values</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">value</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">node</span><span class="p">.</span><span class="n">next</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">unwrap</span><span class="p">()</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">values</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">])</span><span class="w"></span>
</pre></div>


<p>Hurray! We have a cycle with <code>&amp;T</code> references in Rust.
But it’s not very useful yet:
this program hard-codes how many values are involves,
and creates them at the same time.</p>
<h3>A simple arena allocator, with <code>Vec</code> and <code>RefCell</code></h3>
<p>So we want to dynamically allocate a number of nodes to be owned by some shared storage,
and allow nodes to borrow each other from that storage.
The nodes will all be destroyed around the same time, when the storage is dropped.</p>
<p>This pattern has existed before Rust, it’s called an <em>arena allocator</em>.
Implementing it requires using some <code>unsafe</code> code,
but Rust’s borrowing enables us to make it provide a safe API
(by keeping it in a module so that other code cannot mess with its private fields).</p>
<p>Here a simple arena implementation, followed by some code using it similar to above.</p>
<div class="codehilite"><pre><span></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">cell</span>::<span class="n">RefCell</span><span class="p">;</span><span class="w"></span>

<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Arena</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">chunks</span>: <span class="nc">RefCell</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Arena</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Arena</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">Arena</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">chunks</span>: <span class="nc">RefCell</span>::<span class="n">new</span><span class="p">(</span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="nb">Vec</span>::<span class="n">with_capacity</span><span class="p">(</span><span class="mi">8</span><span class="p">)]),</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">allocate</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">value</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">T</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">chunks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">chunks</span><span class="p">.</span><span class="n">borrow_mut</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">chunks</span><span class="p">.</span><span class="n">last</span><span class="p">().</span><span class="n">unwrap</span><span class="p">().</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">chunks</span><span class="p">.</span><span class="n">last</span><span class="p">().</span><span class="n">unwrap</span><span class="p">().</span><span class="n">capacity</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">new_capacity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">chunks</span><span class="p">.</span><span class="n">last</span><span class="p">().</span><span class="n">unwrap</span><span class="p">().</span><span class="n">capacity</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">chunks</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="nb">Vec</span>::<span class="n">with_capacity</span><span class="p">(</span><span class="n">new_capacity</span><span class="p">))</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="n">chunks</span><span class="p">.</span><span class="n">last_mut</span><span class="p">().</span><span class="n">unwrap</span><span class="p">().</span><span class="n">push</span><span class="p">(</span><span class="n">value</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">value_ptr</span>: <span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">chunks</span><span class="p">.</span><span class="n">last</span><span class="p">().</span><span class="n">unwrap</span><span class="p">().</span><span class="n">last</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="c1">// Unsafely dereference a raw pointer to artificially</span>
<span class="w">            </span><span class="c1">// extend the lifetime of the returned reference</span>
<span class="w">            </span><span class="o">&amp;*</span><span class="n">value_ptr</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">/////////////</span>

<span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">cell</span>::<span class="n">Cell</span><span class="p">;</span><span class="w"></span>
<span class="k">struct</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="na">&#39;arena</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">value</span>: <span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">next</span>: <span class="nc">Cell</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="na">&#39;arena</span><span class="w"> </span><span class="n">Node</span><span class="o">&lt;</span><span class="na">&#39;arena</span><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="c1">// impl&lt;&#39;arena&gt; Drop for Node&lt;&#39;arena&gt; { fn drop(&amp;mut self) {} }</span>

<span class="kd">let</span><span class="w"> </span><span class="n">arena</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Arena</span>::<span class="n">new</span><span class="p">();</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arena</span><span class="p">.</span><span class="n">allocate</span><span class="p">(</span><span class="n">Node</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">value</span>: <span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="n">next</span>: <span class="nc">Cell</span>::<span class="n">new</span><span class="p">(</span><span class="nb">None</span><span class="p">)</span><span class="w"> </span><span class="p">});</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arena</span><span class="p">.</span><span class="n">allocate</span><span class="p">(</span><span class="n">Node</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">value</span>: <span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="n">next</span>: <span class="nc">Cell</span>::<span class="n">new</span><span class="p">(</span><span class="nb">Some</span><span class="p">(</span><span class="n">c</span><span class="p">))</span><span class="w"> </span><span class="p">});</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arena</span><span class="p">.</span><span class="n">allocate</span><span class="p">(</span><span class="n">Node</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">value</span>: <span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">next</span>: <span class="nc">Cell</span>::<span class="n">new</span><span class="p">(</span><span class="nb">Some</span><span class="p">(</span><span class="n">b</span><span class="p">))</span><span class="w"> </span><span class="p">});</span><span class="w"></span>

<span class="n">c</span><span class="p">.</span><span class="n">next</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="nb">Some</span><span class="p">(</span><span class="n">b</span><span class="p">));</span><span class="w"></span>

<span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">values</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Vec</span>::<span class="n">new</span><span class="p">();</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="p">..</span><span class="mi">10</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">values</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">value</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">node</span><span class="p">.</span><span class="n">next</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">unwrap</span><span class="p">()</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">values</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">])</span><span class="w"></span>
</pre></div>


<p>The idea is to keep <code>T</code> nodes in a <code>Vec&lt;T&gt;</code>,
and be careful to never to push beyond the initial capacity.
When a vector reaches its capacity, we create a new one
(growing them exponentially to amortize the allocation cost,
much like <code>Vec</code> itself would do if pushed beyond its capacity).
That way, the inner vectors of <code>T</code> are never reallocated,
and references to existing items stay valid.</p>
<p>The one <code>unsafe</code> block is small,
but its soundness relies on the entire module maintaining this invariant
of not moving already-allocated items.</p>
<h3>A faster arena, with raw pointers and <code>#[may_dangle]</code></h3>
<p>The arena implementation above isn’t bad (allocation is already <em>O(1)</em> amortized),
but it was written to be easy to read.
We can easily move things around to avoid for example redundant <code>.last().unwrap()</code> calls,
but calling <code>RefCell::borrow_mut</code> and <code>Vec::push</code> is still more work than strictly necessary.</p>
<p>In Rust an arena happens to enable ergonomic reference cycles,
but it is more typically used as a more efficient alternative to heap allocation.
If used in a tight loop, micro-optimizations can add up to be significant.
Ideally, the fast path of <code>Arena::allocate</code> (when the current chunk isn’t full yet)
would do nothing more than move the value and increment a pointer.</p>
<div class="codehilite"><pre><span></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">cell</span>::<span class="p">{</span><span class="n">Cell</span><span class="p">,</span><span class="w"> </span><span class="n">RefCell</span><span class="p">};</span><span class="w"></span>

<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Arena</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Box&lt;[T]&gt; is similar to Vec&lt;T&gt; where len() == capacity()</span>
<span class="w">    </span><span class="n">full_chunks</span>: <span class="nc">RefCell</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="p">[</span><span class="n">T</span><span class="p">]</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span><span class="w"></span>

<span class="w">    </span><span class="c1">// This has a different memory representation, but is equivalent to Vec&lt;T&gt;</span>
<span class="w">    </span><span class="n">start</span>: <span class="nc">Cell</span><span class="o">&lt;*</span><span class="k">mut</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">next</span>: <span class="nc">Cell</span><span class="o">&lt;*</span><span class="k">mut</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">end</span>: <span class="nc">Cell</span><span class="o">&lt;*</span><span class="k">mut</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Arena</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="n">std</span>::<span class="n">mem</span>::<span class="n">size_of</span>::<span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="s">&quot;this arena cannot be used with zero-sized types&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">unimplemented</span><span class="o">!</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">allocate</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">item</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">T</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">next</span><span class="p">.</span><span class="n">get</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">end</span><span class="p">.</span><span class="n">get</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">new_chunk</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">next</span><span class="p">.</span><span class="n">get</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">std</span>::<span class="n">ptr</span>::<span class="n">write</span><span class="p">(</span><span class="n">next</span><span class="p">,</span><span class="w"> </span><span class="n">item</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">next</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="n">next</span><span class="p">.</span><span class="n">offset</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span><span class="w"></span>
<span class="w">            </span><span class="o">&amp;*</span><span class="n">next</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="cp">#[inline(never)]</span><span class="w"></span>
<span class="w">    </span><span class="cp">#[cold]</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">new_chunk</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">unimplemented</span><span class="o">!</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Swap self.start/next/end with a new Vec&lt;T&gt;</span>
<span class="w">        </span><span class="c1">// and push the old (full) one to self.full_chunks.</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Drop</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Arena</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">unimplemented</span><span class="o">!</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Vec::from_raw_parts() based on self.start/next/end,</span>
<span class="w">        </span><span class="c1">// then let Vec::drop do its work.</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">/////////////</span>

<span class="k">struct</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="na">&#39;arena</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">value</span>: <span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">next</span>: <span class="nc">Cell</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="na">&#39;arena</span><span class="w"> </span><span class="n">Node</span><span class="o">&lt;</span><span class="na">&#39;arena</span><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="kd">let</span><span class="w"> </span><span class="n">arena</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Arena</span>::<span class="n">new</span><span class="p">();</span><span class="w"></span>

<span class="c1">// error[E0597]: `arena` does not live long enough</span>
<span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arena</span><span class="p">.</span><span class="n">allocate</span><span class="p">(</span><span class="n">Node</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">value</span>: <span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">next</span>: <span class="nc">Cell</span>::<span class="n">new</span><span class="p">(</span><span class="nb">None</span><span class="p">)</span><span class="w"> </span><span class="p">});</span><span class="w"></span>
<span class="c1">//      ^^^^^ borrowed value does not live long enough</span>
<span class="kd">let</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arena</span><span class="p">.</span><span class="n">allocate</span><span class="p">(</span><span class="n">Node</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">value</span>: <span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="n">next</span>: <span class="nc">Cell</span>::<span class="n">new</span><span class="p">(</span><span class="nb">Some</span><span class="p">(</span><span class="n">a</span><span class="p">))</span><span class="w"> </span><span class="p">});</span><span class="w"></span>
<span class="c1">//      ^^^^^ borrowed value does not live long enough</span>
<span class="n">a</span><span class="p">.</span><span class="n">next</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="nb">Some</span><span class="p">(</span><span class="n">b</span><span class="p">));</span><span class="w"></span>

<span class="c1">// `arena` dropped here while still borrowed</span>
<span class="c1">// note: values in a scope are dropped in the opposite order they are created</span>
</pre></div>


<p>Some implementation details are left out as they’re not terribly important for this post.
But this much hopefully shows the idea… and the the compiler isn’t happy with it.</p>
<p>So what changed?</p>
<h3>Drop checking</h3>
<p>Compared to our previous <code>Arena</code> type, this one explicitly implements <code>Drop</code>.
The <code>drop</code> method obviously has access to the fields of <code>self</code>,
so if a <code>&amp;U</code> reference is reachable from there it must be valid.
(Even if this particular <code>Drop</code> impl happens not to access those references.)</p>
<p>In other words, the mere existence of a <code>Drop</code> impl affects borrow-checking.
This is called <a href="https://doc.rust-lang.org/nomicon/dropck.html">drop-checking</a>.</p>
<p>We would have a similar issue if <code>Node</code> itself implemented <code>Drop</code>:
some nodes in a cycles would necessarily be dropped after others,
and their <code>drop</code> method would “see” invalid <code>&amp;Node</code> references.
In that case we can work around this limitation by only implementing <code>Drop</code>
on only some fields of <code>Node</code>, separate from those that contain references to other nodes.</p>
<p>For cases like <code>Arena</code> though, the language provides
<a href="https://rust-lang.github.io/rfcs/1327-dropck-param-eyepatch.html">an escape hatch</a>.
We need to make three changes:</p>
<ul>
<li>Add a <code>#[may_dangle]</code> attribute on the <code>T</code> type parameter of the <code>Drop</code> impl.
  This indicates that we opt into allowing <code>T</code> to contain dangling <code>&amp;_</code> references.</li>
<li>Change the <code>impl</code> keyword to <code>unsafe impl</code>,
  to recognize that it’s our responsibility to not access these references.</li>
<li>Add a <code>feature</code> attribute to the crate to opt into using the two unstable features
  of attribute syntax on type parameters and of the <code>may_dangle</code> attribute itself,
  and use a Nightly version of Rust.
  These features are current as of Rust 1.25, but they might still change
  (or even be removed entirely).</li>
</ul>
<div class="codehilite"><pre><span></span><span class="cp">#![feature(generic_param_attrs, dropck_eyepatch)]</span><span class="w"></span>

<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Arena</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">start</span>: <span class="nc">std</span>::<span class="n">cell</span>::<span class="n">Cell</span><span class="o">&lt;*</span><span class="k">mut</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="c1">// …</span>
<span class="p">}</span><span class="w"></span>

<span class="k">unsafe</span><span class="w"> </span><span class="k">impl</span><span class="o">&lt;</span><span class="cp">#[may_dangle]</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Drop</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Arena</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// …</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>Why didn’t we need this before, with <code>RefCell&lt;Vec&lt;Vec&lt;T&gt;&gt;&gt;</code>?
In fact we did.
<code>Vec</code> took care of it for us, <a href="https://github.com/rust-lang/rust/blob/1.24.0/src/liballoc/vec.rs#L2123">with <code>#[may_dangle]</code>
on its own <code>Drop</code> impl</a>.</p>
<p>The standard library is allowed to use unstable language features, even on Stable,
because it is always updated together with the compiler.</p>
<h3>Working around drop-checking on Rust Stable</h3>
<p>So now we have an efficient arena allocator, but it works on Rust Nightly.
This isn’t great, especially for a library that might be used by other people.
Can we avoid using the unstable <code>#[may_dangle]</code> attribute?</p>
<p>The current rules of drop-checking are fairly conservative.
They kick in as soon as an <code>impl Drop</code> block is generic over some type parameter.
Of course we still want <code>Arena&lt;T&gt;</code> to be generic,
and we still want <em>a</em> <code>Drop</code> impl that needs to know how to destruct <code>T</code> items.
The trick is to have them separately,
and store a pointer to a concrete instance of a generic function:</p>
<div class="codehilite"><pre><span></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">cell</span>::<span class="p">{</span><span class="n">RefCell</span><span class="p">,</span><span class="w"> </span><span class="n">Cell</span><span class="p">};</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">mem</span><span class="p">;</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">ptr</span><span class="p">;</span><span class="w"></span>

<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Arena</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">full_chunks</span>: <span class="nc">RefCell</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="p">[</span><span class="n">T</span><span class="p">]</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">current_chunk</span>: <span class="nc">PartiallyFullChunk</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Not parameterized over `T`</span>
<span class="k">struct</span> <span class="nc">PartiallyFullChunk</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">start</span>: <span class="nc">Cell</span><span class="o">&lt;*</span><span class="k">mut</span><span class="w"> </span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">next</span>: <span class="nc">Cell</span><span class="o">&lt;*</span><span class="k">mut</span><span class="w"> </span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">end</span>: <span class="nc">Cell</span><span class="o">&lt;*</span><span class="k">mut</span><span class="w"> </span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">drop</span>: <span class="nc">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">PartiallyFullChunk</span><span class="p">),</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Arena</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="n">mem</span>::<span class="n">size_of</span>::<span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;this arena cannot be used with zero-sized types&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">Arena</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">full_chunks</span>: <span class="nc">RefCell</span>::<span class="n">new</span><span class="p">(</span><span class="nb">Vec</span>::<span class="n">new</span><span class="p">()),</span><span class="w"></span>
<span class="w">            </span><span class="n">current_chunk</span>: <span class="nc">PartiallyFullChunk</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="c1">// An empty arena doesn’t allocate</span>
<span class="w">                </span><span class="n">start</span>: <span class="nc">Cell</span>::<span class="n">new</span><span class="p">(</span><span class="n">ptr</span>::<span class="n">null_mut</span><span class="p">()),</span><span class="w"></span>
<span class="w">                </span><span class="n">next</span>: <span class="nc">Cell</span>::<span class="n">new</span><span class="p">(</span><span class="n">ptr</span>::<span class="n">null_mut</span><span class="p">()),</span><span class="w"></span>
<span class="w">                </span><span class="n">end</span>: <span class="nc">Cell</span>::<span class="n">new</span><span class="p">(</span><span class="n">ptr</span>::<span class="n">null_mut</span><span class="p">()),</span><span class="w"></span>

<span class="w">                </span><span class="c1">// Instanciate a generic function, but don’t call it (yet).</span>
<span class="w">                </span><span class="c1">// Only take a pointer to it.</span>
<span class="w">                </span><span class="n">drop</span>: <span class="nc">drop_partially_full_chunk</span>::<span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// …</span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// This function is generic over `T`…</span>
<span class="k">fn</span> <span class="nf">drop_partially_full_chunk</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">chunk</span>: <span class="kp">&amp;</span><span class="nc">PartiallyFullChunk</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">unimplemented</span><span class="o">!</span><span class="p">()</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// … but this Drop impl or the struct are not.</span>
<span class="k">impl</span><span class="w"> </span><span class="nb">Drop</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">PartiallyFullChunk</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">drop</span><span class="p">)(</span><span class="bp">self</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>


<p>This has some additional run-time cost:
storing an extra pointer per arena, and making one dynamic function call when dropping it.
However this cost should be small or negligible,
assuming that a typical program has few arenas (even if it has many nodes in them).</p>
<p>See <a href="https://github.com/SimonSapin/victor/blob/824b6950027e42/victor/src/arena.rs"><code>victor/src/arena.rs</code></a>
for a full implementation with tests.</p>
